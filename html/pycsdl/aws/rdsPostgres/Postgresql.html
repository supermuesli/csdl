<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pycsdl.aws.rdsPostgres.Postgresql API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycsdl.aws.rdsPostgres.Postgresql</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from csdl import *


class Postgresql(CCS):
    def __init__(self):
        super().__init__()
        self.setId(&#34;https://github.com/supermuesli/csdl&#34;, &#34;aws/rdsPostgres/Postgresql.py&#34;)
        self.extendsId = &#34;SQLDatabaseAsAService&#34;

        # inherited fields
        self.name = &#34;Amazon Web Services - Managed PostgreSQL&#34;
        self.provider = &#34;Amazon Web Services&#34;
        self.searchKeyWords = [&#34;aws&#34;, &#34;psql&#34;, &#34;database as a service&#34;, &#34;db&#34;, &#34;postgres&#34;]  # help users find this model
        self.readme = &#34;enjoy&#34;

        self.ssdStorage = Attribute()
        self.ssdStorage.minVal = 20
        self.ssdStorage.maxVal = 64 * 1000
        self.ssdStorage.mutable = True

        self.iopsSSDStorage = Attribute()
        self.iopsSSDStorage.minVal = 100
        self.iopsSSDStorage.maxVal = 64 * 1000
        self.iopsSSDStorage.mutable = True

        self.magneticStorage = Attribute()
        self.magneticStorage.minVal = 20
        self.magneticStorage.maxVal = 3 * 1000
        self.magneticStorage.mutable = True

        self.region = Attribute()
        self.region.inject(&#34;https://github.com/supermuesli/csdl&#34;, &#34;aws/regions/Region.py&#34;)
        self.region.mutable = True

        self.azDeployment = Attribute()
        self.azDeployment.inject(&#34;https://github.com/supermuesli/csdl&#34;, &#34;aws/rdsPostgres/AvailabilityZone.py&#34;)
        self.azDeployment.mutable = True

        class dbInstancePrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;price per database instance per hour&#34;

            def run(self, req):
                # discover an availabilityZone field in req
                azMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@aws/rdsPostgres/AvailabilityZone.py@latest&#34;)

                # discover a region field in req
                regionMatch = matchAttribute(req, &#34;Region&#34;)

                ramMatch = matchAttribute(req, &#34;Ram&#34;)
                cpuMatch = matchAttribute(req, &#34;CpuCores&#34;)

                if ramMatch is not None:
                    if ramMatch.value is not None:
                        if cpuMatch is not None:
                            if cpuMatch.value is not None:
                                # figure out which ec2 instance matches with given ram and cpu
                                # https://aws.amazon.com/ec2/instance-types/t4/

                                if ramMatch.value == 1 and cpuMatch.value == 1:
                                    # dbt4gmicro

                                    if azMatch is not None:
                                        if azMatch.value is not None:
                                            if azMatch.value == &#34;single&#34;:

                                                if regionMatch is not None:
                                                    if regionMatch.value is not None:
                                                        if regionMatch.value == &#34;northernVirginia&#34;:
                                                            return 0.016

                                            if azMatch.value == &#34;multi&#34;:

                                                if regionMatch is not None:
                                                    if regionMatch.value is not None:
                                                        if regionMatch.value == &#34;northernVirginia&#34;:
                                                            return 0.032

                # defaults to t4gmicro with single availability zone in northernVirginia
                return 0.016

        class storagePrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;storage price per hour&#34;

            def run(self, req):
                # discover an ssd storage field in req
                ssdStorageMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/SSDStorage.py@latest&#34;)

                # discover an ssd storage field in req
                iopsSsdStorageMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/IOPSSSDStorage.py@latest&#34;)

                # discover an ssd storage field in req
                iopsMagneticStorageMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/IOPSMagneticStorage.py@latest&#34;)

                # default to general purpose ssd storage
                if ssdStorageMatch is None and iopsMagneticStorageMatch is None and iopsSsdStorageMatch is None:
                    ssdStorageMatch = matchAttribute(req, &#34;Storage&#34;)

                    if ssdStorageMatch is None:
                        return 0

                # discover an availabilityZone field in req
                azMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@aws/rdsPostgres/AvailabilityZone.py@latest&#34;)

                # discover a region field in req
                regionMatch = matchAttribute(req, &#34;Region&#34;)

                if azMatch is not None:
                    if azMatch.value is not None:
                        if azMatch.value == &#34;single&#34;:

                            if regionMatch is not None:
                                if regionMatch.value is not None:
                                    if regionMatch.value == &#34;northernVirginia&#34;:

                                        if ssdStorageMatch is not None:
                                            if ssdStorageMatch.value is not None:
                                                # general purpose ssd stoarge single availability zone
                                                return 0.115 * ssdStorageMatch.value / (24*28)

                                        if iopsSsdStorageMatch is not None:
                                            if iopsSsdStorageMatch.value is not None:

                                                # provisioned iops ssd storage single availability zone
                                                storageRes = 0.125 * iopsSsdStorageMatch.value
                                                iopsRes = 0.10 * iopsSsdStorageMatch.iops.value
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                                        if iopsMagneticStorageMatch is not None:
                                            if iopsMagneticStorageMatch.value is not None:
                                                # magnetic storage single availability zone
                                                storageRes = 0.10 * iopsMagneticStorageMatch.value
                                                iopsRes = 0.10 * iopsMagneticStorageMatch.iops.value / 1000000
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period
                                    else:
                                        # region matches, just not with northernVirginia. fallback to a reasonable default
                                        if ssdStorageMatch is not None:
                                            if ssdStorageMatch.value is not None:
                                                # general purpose ssd stoarge single availability zone
                                                return 0.115 * ssdStorageMatch.value / (24*28)

                                        if iopsSsdStorageMatch is not None:
                                            if iopsSsdStorageMatch.value is not None:

                                                # provisioned iops ssd storage single availability zone
                                                storageRes = 0.125 * iopsSsdStorageMatch.value
                                                iopsRes = 0.10 * iopsSsdStorageMatch.iops.value
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                                        if iopsMagneticStorageMatch is not None:
                                            if iopsMagneticStorageMatch.value is not None:
                                                # magnetic storage single availability zone
                                                storageRes = 0.10 * iopsMagneticStorageMatch.value
                                                iopsRes = 0.10 * iopsMagneticStorageMatch.iops.value / 1000000
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                        if azMatch.value == &#34;multi&#34;:

                            if regionMatch is not None:
                                if regionMatch.value is not None:
                                    if regionMatch.value == &#34;northernVirginia&#34;:

                                        if ssdStorageMatch is not None:
                                            if ssdStorageMatch.value is not None:
                                                # general purpose ssd stoarge multi availability zone
                                                return 0.23 * ssdStorageMatch.value / (24*28)

                                        if iopsSsdStorageMatch is not None:
                                            if iopsSsdStorageMatch.value is not None:
                                                # provisioned iops ssd storage multi availability zone
                                                storageRes = 0.25 * iopsSsdStorageMatch.value
                                                iopsRes = 0.20 * iopsSsdStorageMatch.iops.value
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                                        if iopsMagneticStorageMatch is not None:
                                            if iopsMagneticStorageMatch.value is not None:
                                                # magnetic storage multi availability zone
                                                storageRes = 0.20 * iopsMagneticStorageMatch.value
                                                iopsRes = 0.10 * iopsMagneticStorageMatch.iops.value / 1000000
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                return 0

        class backupPrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;backup price per hour&#34;

            def run(self, req):
                # how many months to keep a backup
                retentionPeriodMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/BackupRetentionPeriod.py@latest&#34;)

                # how many backup snapshots to make per month
                snapshotAmountMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/BackupSnapshotAmount.py@latest&#34;)

                # how much storage is provisioned per billing period (1 hour)
                storageMatch = matchAttribute(req, &#34;Storage&#34;)

                if storageMatch is not None:
                    if storageMatch.value is not None:

                        if snapshotAmountMatch is not None:
                            if snapshotAmountMatch.value is not None:
                                if snapshotAmountMatch.value &gt; 0:

                                    if retentionPeriodMatch is not None:
                                        if retentionPeriodMatch.value is not None:
                                            if retentionPeriodMatch.value &gt; 0:
                                                return 0.095 * storageMatch.value * snapshotAmountMatch.value * retentionPeriodMatch.value / (24*28)

                return 0

        class dataTransferPrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;what you pay for data transfer in and out of the storage server per billing period (1 hour)&#34;

            def run(self, req):
                res = 0

                # discover a region field in req
                regionMatch = matchAttribute(req, &#34;Region&#34;)

                # discover a region field in req
                transferInMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/dataTransfer/In.py@latest&#34;)

                # discover a region field in req
                transferOutMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/dataTransfer/Out.py@latest&#34;)

                if regionMatch is not None:
                    if regionMatch.value is not None:
                        if regionMatch.value == &#34;northernVirginia&#34;:

                            if transferInMatch is not None:
                                if transferInMatch.value is not None:
                                    res += 0.00 * transferInMatch.value  # upload is free

                            if transferOutMatch is not None:
                                if transferOutMatch.value is not None:
                                    if transferOutMatch.value &lt;= 1:
                                        res += 0.00 * transferOutMatch.value
                                    if 1 &lt; transferOutMatch.value &lt;= 1 + 9.999 * 1000:
                                        res += 0.09 * transferOutMatch.value
                                    elif 1 + 9.999 * 1000 &lt; transferOutMatch.value &lt;= 1 + (9.999 + 40) * 1000:
                                        res += 0.085 * transferOutMatch.value
                                    elif 1 + (9.999 + 40) * 1000 &lt; transferOutMatch.value &lt;= 1 + (
                                            9.999 + 40 + 100) * 1000:
                                        res += 0.07 * transferOutMatch.value
                                    elif 1 + (9.999 + 40 + 100) * 1000 &lt; transferOutMatch.value:
                                        res += 0.05 * transferOutMatch.value

                return res

        # price
        self.price.currency = &#34;USD&#34;  # ISO 4217
        self.price.priceFuncs = [dbInstancePrice(), storagePrice(), backupPrice(), dataTransferPrice()]  # https://calculator.aws/#/createCalculator/RDSPostgreSQL

        self.price.model.value = &#34;subscription&#34;
        self.price.model.options[self.price.model.value].upfrontCost = 0
        self.price.model.options[self.price.model.value].billingPeriod = 1  # in hours</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycsdl.aws.rdsPostgres.Postgresql.Postgresql"><code class="flex name class">
<span>class <span class="ident">Postgresql</span></span>
</code></dt>
<dd>
<div class="desc"><p>Instances of the Attribute class have a unique id that encodes from where they can be loaded. Classes that
extend the Attribute class can be matched with other Attributes if they are related, which helps with user
requirement matching and price calculation. Also, classes that have an Attribute type ancestor can be extended
arbitrarily by other Attribute type instances (however, note that existing duplicate fields will be overwritten.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Postgresql(CCS):
    def __init__(self):
        super().__init__()
        self.setId(&#34;https://github.com/supermuesli/csdl&#34;, &#34;aws/rdsPostgres/Postgresql.py&#34;)
        self.extendsId = &#34;SQLDatabaseAsAService&#34;

        # inherited fields
        self.name = &#34;Amazon Web Services - Managed PostgreSQL&#34;
        self.provider = &#34;Amazon Web Services&#34;
        self.searchKeyWords = [&#34;aws&#34;, &#34;psql&#34;, &#34;database as a service&#34;, &#34;db&#34;, &#34;postgres&#34;]  # help users find this model
        self.readme = &#34;enjoy&#34;

        self.ssdStorage = Attribute()
        self.ssdStorage.minVal = 20
        self.ssdStorage.maxVal = 64 * 1000
        self.ssdStorage.mutable = True

        self.iopsSSDStorage = Attribute()
        self.iopsSSDStorage.minVal = 100
        self.iopsSSDStorage.maxVal = 64 * 1000
        self.iopsSSDStorage.mutable = True

        self.magneticStorage = Attribute()
        self.magneticStorage.minVal = 20
        self.magneticStorage.maxVal = 3 * 1000
        self.magneticStorage.mutable = True

        self.region = Attribute()
        self.region.inject(&#34;https://github.com/supermuesli/csdl&#34;, &#34;aws/regions/Region.py&#34;)
        self.region.mutable = True

        self.azDeployment = Attribute()
        self.azDeployment.inject(&#34;https://github.com/supermuesli/csdl&#34;, &#34;aws/rdsPostgres/AvailabilityZone.py&#34;)
        self.azDeployment.mutable = True

        class dbInstancePrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;price per database instance per hour&#34;

            def run(self, req):
                # discover an availabilityZone field in req
                azMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@aws/rdsPostgres/AvailabilityZone.py@latest&#34;)

                # discover a region field in req
                regionMatch = matchAttribute(req, &#34;Region&#34;)

                ramMatch = matchAttribute(req, &#34;Ram&#34;)
                cpuMatch = matchAttribute(req, &#34;CpuCores&#34;)

                if ramMatch is not None:
                    if ramMatch.value is not None:
                        if cpuMatch is not None:
                            if cpuMatch.value is not None:
                                # figure out which ec2 instance matches with given ram and cpu
                                # https://aws.amazon.com/ec2/instance-types/t4/

                                if ramMatch.value == 1 and cpuMatch.value == 1:
                                    # dbt4gmicro

                                    if azMatch is not None:
                                        if azMatch.value is not None:
                                            if azMatch.value == &#34;single&#34;:

                                                if regionMatch is not None:
                                                    if regionMatch.value is not None:
                                                        if regionMatch.value == &#34;northernVirginia&#34;:
                                                            return 0.016

                                            if azMatch.value == &#34;multi&#34;:

                                                if regionMatch is not None:
                                                    if regionMatch.value is not None:
                                                        if regionMatch.value == &#34;northernVirginia&#34;:
                                                            return 0.032

                # defaults to t4gmicro with single availability zone in northernVirginia
                return 0.016

        class storagePrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;storage price per hour&#34;

            def run(self, req):
                # discover an ssd storage field in req
                ssdStorageMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/SSDStorage.py@latest&#34;)

                # discover an ssd storage field in req
                iopsSsdStorageMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/IOPSSSDStorage.py@latest&#34;)

                # discover an ssd storage field in req
                iopsMagneticStorageMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/IOPSMagneticStorage.py@latest&#34;)

                # default to general purpose ssd storage
                if ssdStorageMatch is None and iopsMagneticStorageMatch is None and iopsSsdStorageMatch is None:
                    ssdStorageMatch = matchAttribute(req, &#34;Storage&#34;)

                    if ssdStorageMatch is None:
                        return 0

                # discover an availabilityZone field in req
                azMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@aws/rdsPostgres/AvailabilityZone.py@latest&#34;)

                # discover a region field in req
                regionMatch = matchAttribute(req, &#34;Region&#34;)

                if azMatch is not None:
                    if azMatch.value is not None:
                        if azMatch.value == &#34;single&#34;:

                            if regionMatch is not None:
                                if regionMatch.value is not None:
                                    if regionMatch.value == &#34;northernVirginia&#34;:

                                        if ssdStorageMatch is not None:
                                            if ssdStorageMatch.value is not None:
                                                # general purpose ssd stoarge single availability zone
                                                return 0.115 * ssdStorageMatch.value / (24*28)

                                        if iopsSsdStorageMatch is not None:
                                            if iopsSsdStorageMatch.value is not None:

                                                # provisioned iops ssd storage single availability zone
                                                storageRes = 0.125 * iopsSsdStorageMatch.value
                                                iopsRes = 0.10 * iopsSsdStorageMatch.iops.value
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                                        if iopsMagneticStorageMatch is not None:
                                            if iopsMagneticStorageMatch.value is not None:
                                                # magnetic storage single availability zone
                                                storageRes = 0.10 * iopsMagneticStorageMatch.value
                                                iopsRes = 0.10 * iopsMagneticStorageMatch.iops.value / 1000000
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period
                                    else:
                                        # region matches, just not with northernVirginia. fallback to a reasonable default
                                        if ssdStorageMatch is not None:
                                            if ssdStorageMatch.value is not None:
                                                # general purpose ssd stoarge single availability zone
                                                return 0.115 * ssdStorageMatch.value / (24*28)

                                        if iopsSsdStorageMatch is not None:
                                            if iopsSsdStorageMatch.value is not None:

                                                # provisioned iops ssd storage single availability zone
                                                storageRes = 0.125 * iopsSsdStorageMatch.value
                                                iopsRes = 0.10 * iopsSsdStorageMatch.iops.value
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                                        if iopsMagneticStorageMatch is not None:
                                            if iopsMagneticStorageMatch.value is not None:
                                                # magnetic storage single availability zone
                                                storageRes = 0.10 * iopsMagneticStorageMatch.value
                                                iopsRes = 0.10 * iopsMagneticStorageMatch.iops.value / 1000000
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                        if azMatch.value == &#34;multi&#34;:

                            if regionMatch is not None:
                                if regionMatch.value is not None:
                                    if regionMatch.value == &#34;northernVirginia&#34;:

                                        if ssdStorageMatch is not None:
                                            if ssdStorageMatch.value is not None:
                                                # general purpose ssd stoarge multi availability zone
                                                return 0.23 * ssdStorageMatch.value / (24*28)

                                        if iopsSsdStorageMatch is not None:
                                            if iopsSsdStorageMatch.value is not None:
                                                # provisioned iops ssd storage multi availability zone
                                                storageRes = 0.25 * iopsSsdStorageMatch.value
                                                iopsRes = 0.20 * iopsSsdStorageMatch.iops.value
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                                        if iopsMagneticStorageMatch is not None:
                                            if iopsMagneticStorageMatch.value is not None:
                                                # magnetic storage multi availability zone
                                                storageRes = 0.20 * iopsMagneticStorageMatch.value
                                                iopsRes = 0.10 * iopsMagneticStorageMatch.iops.value / 1000000
                                                return (storageRes + iopsRes) / (24*28) # price description on the website was
                                                                           # per month, so we converted that to
                                                                           # per hour, since that is the billing
                                                                           # period

                return 0

        class backupPrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;backup price per hour&#34;

            def run(self, req):
                # how many months to keep a backup
                retentionPeriodMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/BackupRetentionPeriod.py@latest&#34;)

                # how many backup snapshots to make per month
                snapshotAmountMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/storage/BackupSnapshotAmount.py@latest&#34;)

                # how much storage is provisioned per billing period (1 hour)
                storageMatch = matchAttribute(req, &#34;Storage&#34;)

                if storageMatch is not None:
                    if storageMatch.value is not None:

                        if snapshotAmountMatch is not None:
                            if snapshotAmountMatch.value is not None:
                                if snapshotAmountMatch.value &gt; 0:

                                    if retentionPeriodMatch is not None:
                                        if retentionPeriodMatch.value is not None:
                                            if retentionPeriodMatch.value &gt; 0:
                                                return 0.095 * storageMatch.value * snapshotAmountMatch.value * retentionPeriodMatch.value / (24*28)

                return 0

        class dataTransferPrice(PriceFunc):
            def __init__(self):
                super().__init__()
                self.description = &#34;what you pay for data transfer in and out of the storage server per billing period (1 hour)&#34;

            def run(self, req):
                res = 0

                # discover a region field in req
                regionMatch = matchAttribute(req, &#34;Region&#34;)

                # discover a region field in req
                transferInMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/dataTransfer/In.py@latest&#34;)

                # discover a region field in req
                transferOutMatch = matchAttribute(req, &#34;https://github.com/supermuesli/csdl@misc/dataTransfer/Out.py@latest&#34;)

                if regionMatch is not None:
                    if regionMatch.value is not None:
                        if regionMatch.value == &#34;northernVirginia&#34;:

                            if transferInMatch is not None:
                                if transferInMatch.value is not None:
                                    res += 0.00 * transferInMatch.value  # upload is free

                            if transferOutMatch is not None:
                                if transferOutMatch.value is not None:
                                    if transferOutMatch.value &lt;= 1:
                                        res += 0.00 * transferOutMatch.value
                                    if 1 &lt; transferOutMatch.value &lt;= 1 + 9.999 * 1000:
                                        res += 0.09 * transferOutMatch.value
                                    elif 1 + 9.999 * 1000 &lt; transferOutMatch.value &lt;= 1 + (9.999 + 40) * 1000:
                                        res += 0.085 * transferOutMatch.value
                                    elif 1 + (9.999 + 40) * 1000 &lt; transferOutMatch.value &lt;= 1 + (
                                            9.999 + 40 + 100) * 1000:
                                        res += 0.07 * transferOutMatch.value
                                    elif 1 + (9.999 + 40 + 100) * 1000 &lt; transferOutMatch.value:
                                        res += 0.05 * transferOutMatch.value

                return res

        # price
        self.price.currency = &#34;USD&#34;  # ISO 4217
        self.price.priceFuncs = [dbInstancePrice(), storagePrice(), backupPrice(), dataTransferPrice()]  # https://calculator.aws/#/createCalculator/RDSPostgreSQL

        self.price.model.value = &#34;subscription&#34;
        self.price.model.options[self.price.model.value].upfrontCost = 0
        self.price.model.options[self.price.model.value].billingPeriod = 1  # in hours</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>csdl.CCS</li>
<li>csdl.Attribute</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycsdl.aws.rdsPostgres" href="index.html">pycsdl.aws.rdsPostgres</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycsdl.aws.rdsPostgres.Postgresql.Postgresql" href="#pycsdl.aws.rdsPostgres.Postgresql.Postgresql">Postgresql</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>